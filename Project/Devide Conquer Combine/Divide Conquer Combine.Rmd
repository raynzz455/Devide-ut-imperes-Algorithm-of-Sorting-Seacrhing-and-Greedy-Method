---
title: "Mini Project Kelompok 10"
author: "Raynaldi, Muhammad Taqi Husaini, Fahri Muhammad"
date: "2025-12-04"
output:
  html_document:
---

```{r html-deps, echo=FALSE}
htmltools::attachDependencies(
  htmltools::tagList(),
  htmltools::htmlDependency(
    name = "custom-toc",
    version = "1.0.0",
    src = "../assets",
    script = "js/script.js",
    stylesheet = c("css/style.css","font/font.css")
  )
)
```

:::{.main-title}
<div class="title-main"> Divide, Conquer, Combine </div>
<div class="title-sub"> Pertemuan 9 </div> 
:::

<nav id="custom-toc" aria-label="Daftar Isi">

::: {#toc-title}
  DAFTAR ISI
:::

::: {#toc-content}
:::

</nav>
:::{.container1}

:::{.header-container}
# Definisi
:::

:::{.content-container}
## Divide

Divide adalah tahap yang memecah masalah integer programming kompleks menjadi sub-masalah yang lebih kecil dan terstruktur, dilakukan secara rekursif untuk mencapai ukuran yang memungkinkan penyelesaian lebih mudah dan efisien.

## Conquer
Conquer menyelesaikan sub-masalah secara independen, menggunakan teknik optimasi lokal yang sesuai atau penyelesaian langsung jika sub-masalah mencapai kondisi dasar, sehingga mempercepat proses pemecahan masalah keseluruhan.

## Combine

Combine menggabungkan solusi-solusi sub-masalah menjadi solusi global yang optimal dengan metode agregasi yang efisien, memastikan hasil akhir memenuhi kriteria solusi terbaik untuk masalah asli.
:::
:::

:::{.container1}
:::{.header-container}
# Konsep Tambahan
:::
<p style="margin-bottom: 20px;"> 
Dalam paradigma Divide, Conquer, dan Combine, terdapat 4 konsep tambahan yang memperkaya proses algoritma ini. **Branching factor dan balance** berperan pada tahap **Divide**, dimana branching factor menentukan jumlah sub-bagian yang dihasilkan saat memecah masalah, sementara balance memastikan setiap sub-bagian memiliki ukuran seragam agar pemrosesan efisien. Selanjutnya **data dependence of divide function** pada **Divide** menyesuaikan pembagian berdasarkan nilai data, dan pada tahap **Conquer** konsep **control parallelism or sequentially** memungkinkan pilihan antara pemrosesan paralel untuk kecepatan atau sequential untuk eksekusi berurutan. Semua konsep ini terintegrasi hingga tahap **Combine** yang menggabungkan solusi sub-masalah menjadi hasil akhir optimal.
</p>


:::{.content-container}
:::{.special-header}
## Branching Factor
:::
### Pengertian
**Branching factor** adalah jumlah sub-bagian yang dihasilkan saat memecah masalah menjadi bagian-bagian yang lebih kecil pada langkah Divide. Semakin banyak bagian yang dihasilkan pada setiap langkah, semakin tinggi branching factor-nya, sehingga memengaruhi kompleksitas rekursi keseluruhan dalam proses Divide, Conquer, dan Combine.

### Contoh

Misalkan ada array nilai ujian: `[7, 2, 9, 4, 5, 1, 8, 3]`.\
Algoritma akan selalu membagi array menjadi 2 bagian hampir sama besar di langkah Divide:

- Langkah 1: `[7,2,9,4,5,1,8,3]` → `[7,2,9,4]` dan `[5,1,8,3]` (2 submasalah)

- Langkah 2: `[7,2,9,4]` → `[7,2]` dan `[9,4]` (2 submasalah lagi), dst.

Di setiap pemanggilan rekursi, masalah dipecah menjadi 2 submasalah → branching factor = 2.

**Implementasi Syntax R**
```{r}
branching_once <- function(vec) {
  # Langkah 1
  cat("Langkah 1:", vec, "\n")
  mid1 <- floor(length(vec) / 2)
  left1  <- vec[1:mid1]
  right1 <- vec[(mid1 + 1):length(vec)]
  cat("  →", left1, "dan", right1, "(2 submasalah)\n\n")
  
  # Langkah 2: pecah bagian kiri dari langkah 1
  cat("Langkah 2:", left1, "\n")
  mid2 <- floor(length(left1) / 2)
  left2  <- left1[1:mid2]
  right2 <- left1[(mid2 + 1):length(left1)]
  cat("  →", left2, "dan", right2, "(2 submasalah lagi)\n")
}

x <- c(7, 2, 9, 4, 5, 1, 8, 3)
branching_once(x)
```
**Intinya**\
Branching Factor menunjukkan seberapa banyak bagian kecil yang dihasilkan pada setiap langkah.
:::

:::{.content-container}
:::{.special-header}
## Balance
:::
### Pengertian

**Balance** memiliki arti bahwa setiap sub-bagian yang dipecah pada tahap **Divide** memiliki ukuran atau beban yang sama sehingga proses pemecahannya adil dan efisien, menghindari ketidakseimbangan yang dapat menurunkan performa algoritma secara keseluruhan.

### Contoh

- `[4, 8, 2, 6]` → `[4, 8]` dan `[2, 6]` (2 dan 2, seimbang)

- `[10, 3, 5, 7, 9, 1]` → `[10, 3, 5]` dan `[7, 9, 1]` (3 dan 3, seimbang)

**Implementasi syntax R**
```{r}
split_balanced <- function(vec) {
  n <- length(vec)
  
  if (n <= 1) {
    return(list(left = vec, right = c()))
  }
  
  mid <- floor(n / 2)
  left  <- vec[1:mid]
  right <- vec[(mid + 1):n]
  
  list(left = left, right = right)
}

# Contoh 1
v1 <- c(3, 5, 2, 7)
split_balanced(v1)

# Contoh 2
v2 <- c(11, 5, 7, 3, 9)
split_balanced(v2)
```
**Intinya**\
Balance memastikan pemecahan masalah dilakukan secara efisien dan merata.
:::

:::{.content-container}
:::{.special-header}
## Data Dependence of Divide Function
:::
### Pengertian

**Data Dependence of Divide Function** pada tahap **Divide** bergantung pada nilai-nilai data yang ada, artinya pembagian tidak hanya didasarkan pada jumlah elemen tetapi juga sifat atau nilai data tersebut untuk menentukan cara pemecahan terbaik.

### Contoh

Misalkan ingin mencari nilai 18 pada array terurut: `[5, 9, 12, 15, 18, 21, 24]`.\

- Algoritma melihat elemen tengah yaitu `15` (bukan sekadar membagi `7` elemen menjadi `3` dan `4`, tetapi memakai nilai `15` sebagai acuan).\
- Karena target `(18) > 15`, bagian kiri `[5, 9, 12, 15]` dibuang, dan pencarian hanya dilanjutkan pada bagian kanan `[18, 21, 24]`.\
- Keputusan “buang kiri atau kanan” sepenuhnya bergantung pada perbandingan nilai target dan nilai tengah, jadi fungsi Divide di sini bergantung pada data (data dependent), bukan hanya ukuran. 

**Implementasi syntax R**
```{r}
binary_search_data_dependence <- function(vec, target) {
  left  <- 1
  right <- length(vec)
  
  # hitung indeks tengah
  mid <- floor((left + right) / 2)
  cat("Array :", vec, "\n")
  cat("Target:", target, "\n")
  cat("Indeks tengah:", mid, "dengan nilai", vec[mid], "\n")
  
  if (target == vec[mid]) {
    cat("Target sama dengan nilai tengah → ditemukan di indeks", mid, "\n")
  } else if (target > vec[mid]) {
    cat("Target >", vec[mid], "→ buang bagian kiri", vec[1:mid], "\n")
    cat("Lanjutkan pencarian pada bagian kanan:", vec[(mid + 1):right], "\n")
  } else {
    cat("Target <", vec[mid], "→ buang bagian kanan", vec[mid:right], "\n")
    cat("Lanjutkan pencarian pada bagian kiri:", vec[left:(mid - 1)], "\n")
  }
}

# Contoh pemanggilan
vektor <- c(5, 9, 12, 15, 18, 21, 24)
binary_search_data_dependence(vektor, 18)

```
**Intinya**\
Pembagian mempertimbangkan nilai elemen agar pemecahan lebih efektif.

------------------------------------------------------------------------
:::

:::{.content-container}
:::{.special-header}
## Control Parallelism dan Sequentially
:::
### Control Parallelism

**Control Parallelism** pada tahap **Conquer** adalah pendekatan yang memungkinkan bagian-bagian dari masalah diproses secara bersamaan setelah dibagi, sehingga mempercepat pemrosesan dengan memanfaatkan sumber daya komputasi secara paralel.

**Contoh**\ 
Misalkan ada data waktu belajar harian seorang mahasiswa dalam jam: `[2, 4, 6, 8]`\
Mahasiswa ingin mengetahui total jam belajar. Dengan pendekatan divide and conquer:

- Langkah 1 (Divide): data dipecah menjadi dua bagian seimbang: [2, 4] dan [6, 8].
- Langkah 2 (Conquer dengan control parallelism): kedua bagian ini boleh diproses secara bersamaan:
  - Hitung jumlah [2, 4] → 6
  - Hitung jumlah [6, 8] → 14
- Langkah 3 (Combine): gabungkan hasil keduanya: 6 + 14 = 20.

Di tahap Conquer, dua penyelesaian sub-masalah “jumlahkan bagian kiri” dan “jumlahkan bagian kanan” adalah independen dan bisa dijalankan paralel jika ada lebih dari satu data.

**Implementasi Syntax R**
```{r}
jam_belajar <- function(vec) {
  if (length(vec) == 1) {
    return(vec[1])
  }
  
  mid <- floor(length(vec) / 2)
  left  <- vec[1:mid]
  right <- vec[(mid + 1):length(vec)]
  
  sum_left  <- jam_belajar(left)   # tugas 1: jumlahkan bagian kiri
  sum_right <- jam_belajar(right)  # tugas 2: jumlahkan bagian kanan
  
  return(sum_left + sum_right)
}

data_belajar <- c(2, 4, 6, 8)
jam_belajar(data_belajar)

```

**Intinya**\
Control Parallelism mempercepat pemrosesan dengan melakukan tugas-tugas secara bersamaan.

### Sequentially

**Sequentially** pada tahap **Conquer** memproses bagian-bagian dari masalah secara berurutan satu per satu setelah dibagi, memastikan setiap sub-masalah diselesaikan secara bergantian tanpa pemrosesan bersamaan.

**Contoh**\
Misalkan ada data waktu belajar harian seorang mahasiswa: `[2, 4, 6, 8]`\
Mahasiswa ingin menghitung total jam belajar, tetapi dilakukan secara berurutan:

- Tambah 2 → total sementara 2
- Tambah 4 → total sementara 6
- Tambah 6 → total sementara 12
- Tambah 8 → total akhir 20

**Implementasi Syntax R**
```{r}
sequential <- function(vec) {
  total <- 0
  for (x in vec) {
    total <- total + x
    cat("Menambahkan", x, "→ total sementara =", total, "\n")
  }
  return(total)
}

data_belajar <- c(2, 4, 6, 8)
sequential(data_belajar)
```

**Intinya**\
Sequentially memastikan bahwa setiap bagian diproses satu per satu, tanpa ada bagian yang diproses bersamaan.

------------------------------------------------------------------------
:::
:::

:::{.container1}
:::{.header-container}
# Ilustrasi dan Kasus
:::
Fahri Muhammad adalah mahasiswa baru Statistika di Universitas Sultan Ageng Tirtayasa (Untirta). Ia sedang mengerjakan tugas Algoritma Pemrograman. Ia punya array NIM 33 teman sekelasnya yang acak: `[3338250042, 3338250027, 3338250058, 3338250019, 3338250034, ...]` tapi untuk presentasi ia ambil 5 NIM pertama dari paling depan.

:::{.content-container}
:::{.special-header}
## **Langkah Algoritma penyelesaiannya**
:::
Fahri terapkan **Merge Sort**:

Divide (Branching Factor: 2): "Pecah dulu jadi 2 bagian balance!"

-   Bagian 1: `[3338250042, 3338250027, 3338250058]` (3 NIM)
-   Bagian 2: `[3338250019, 3338250034]` (2 NIM) Balance 60:40

Divide lagi (Data Dependence: index-based):

-   1a: `[3338250042]`
-   1b: `[3338250027, 3338250058]`
-   2a: `[3338250019]`
-   2b: `[3338250034]`

Conquer (Control Parallelism): "Urutkan 4 sub-array secara paralel" 

- Iterasi 1b: `[3338250027, 3338250058]` -\> Divide: `[3338250027]` + `[3338250058]` -\> sudah urut 
- Semua single element -\> sudah urut

Combine (Sequentially):

-   1a: `[3338250042]` + 1b: `[3338250027, 3338250058]` -\> Bagian 1: `[3338250027, 3338250042, 3338250058]`
-   2a: `[3338250019]` + 2b: `[3338250034]` -\> `[3338250019, 3338250034]`
-   Final: Bagian 1 + Bagian 2 -\> `[3338250019, 3338250027, 3338250034, 3338250042, 3338250058]`

fahri mendapatkan array terurut dikelasnya menggukan prinsip divide, conquer, combine.

Dosen, "Nim dengan nomor belakang `19, 27, 34, 42, 58` silahkan maju kedepan"
:::

:::{.content-container}
:::{.special-header}
## Implementasi R
:::
```{r ilustrasi,  fig.cap="Ilustrasi Divide, Conquer, Combine"}
merge_sort_dc <- function(arr, depth = 0) {
  cat(sprintf("Level %d - Branching Factor: 2\n", depth))
  
  n <- length(arr)
  if(n <= 1) {
    cat(sprintf("Base case: %s\n", paste(arr, collapse=", ")))
    return(arr)
  }
  
  # Divide (Balance & Data Dependence, dan juga Branching Factor)
  mid <- ceiling(n/2)
  left <- arr[1:mid]
  right <- arr[(mid+1):n]
  
  cat(sprintf("Balance: Pecah %d → Left:%d Right:%d (Data Dependence: index-based)\n", 
              n, length(left), length(right)))
  
  # Conquer (Control Parallelism)
  left_sorted <- merge_sort_dc(left, depth+1)
  right_sorted <- merge_sort_dc(right, depth+1)
  
  # Combine (Sequentially)
  result <- merge(left_sorted, right_sorted)
  cat(sprintf("Combine: [%s] + [%s] → [%s]\n", 
              paste(left_sorted, collapse=","), 
              paste(right_sorted, collapse=","), 
              paste(result, collapse=",")))
  return(result)
}

merge <- function(a, b) {
  if(length(a) == 0) return(b)
  if(length(b) == 0) return(a)
  if(a[1] <= b[1]) return(c(a[1], merge(a[-1], b)))
  return(c(b[1], merge(a, b[-1])))
}

# Test
set.seed(123)
nim <- sample(3338250001:3338250099, 5)
cat("NIM Awal:", nim, "\n")
hasil <- merge_sort_dc(nim)
cat("Hasil Terurut:", hasil, "\n")

```

**Penjelasan syntax**

<pre><code>
("Pecah %d → Left:%d Right:%d", n, left, right)
         |    |         |      |       |
         |    |         |      |       → right = 2
         |    |         |      → left = 3
         |    |         → n = 5
         |    → %d (numeric)
         → %d (numeric)
</code></pre>

:::
:::

:::{.container1}
:::{.header-container}
# Daftar Pustaka
:::
::: {#refs}
Yang, C., Ning, X., Yu, D., Sun, H., Kang, G., & Wang, H. (2025). A divide-and-conquer strategy for integer programming problems. Electronic Research Archive, 33(6), 3950-3967. <https://doi.org/10.3934/era.2025175>
:::
:::